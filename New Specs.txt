!   Push the length of the stack
@   Start function
#   Start a comment
$   Swap the top two items
%   Pop x, y, push y % x
^   Reverse the stack
&   Store/Push a value in/from the register
*   Pop x, y, push y * x
()  For loop
[]  If statement
{}  While loop
:   Duplicate top
;   End function
"   Right shift
'   Left shift
<   Less than
>   Greater than
,   Print nice
.   Print raw
?   Take input
/   Pop x, y, push y / x
\   Escape next character
~   Push random number (-inf, +inf)
-   Push x, y, push y - x
_   Pop top of stack
+   Push x, y, push y + x
=   Equals
a-Z Push character literal
0-9 Push numeric literal
`   Start normal string
Â¬   Logical not
â‰    Not Equals
â‰¤   Less than or equal to
â‰¥   Greater than or equal to
â€¹â€º  List
Â°   Pop list, pos, push list[pos]
â€¢   Pop list, pos, val, list[pos] = val
Å“   Apply operator to all of stack
Â£â„¢  Map the expression to the top item iteratively
Æ’â„¢  Map the expression to the whole stack iteratively
Â§â„¢  Switch statement
Â®   Set variable
Â©   Get variable
ÃŸ   Binary List
âŸ¨â„¢  Zip map
â¸¤   Min of zip Map
â¸¢   Max of zip Map
ğŠ—   Base ten
ğŠ‚   Base 2
âˆ‘   Summate the stack
âˆ¨   Max of the stack/item
âˆ§   Min of the stack/item
âˆ†   Increment
â–½   Decrement
á¹˜   range(1, n + 1) [1, n]
á¹š   range(0, n + 1) [0, n]
á¹   range(a, b) [a, b]
á¹™   range(1, n) [1, n)
á¹›   range(0, n) [0, n)
á¹Ÿ   range(a, b) [a, b)
âš   mod 2
âŠ¡   space string
â€³   empty string
Â¢   map but keep original as input
Â§   pairwise map
Î©   print all
Â²   square top
ğŠ–   sort stack
ğŠœ   uniquify
âŠ   wrap in List
â€¦   flatten
áº•   is integer
â„¤   to integer
Â¡   factorial
Ã¸   prefixes of t.o.s
Â±   negate
â‚¬   sub-sum a list
ï¬   filter a list
â„   loop variable
Ë›   Empty string
Â¯   Item in the list
Î»   Predefined constant
ğŠ  Loop variable
âŠ•   Increment
âŠ–   Decrement
